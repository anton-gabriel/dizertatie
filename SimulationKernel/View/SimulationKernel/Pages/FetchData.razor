@page "/fetchdata"

<PageTitle>Items</PageTitle>

@using DomainModel.SimulationKernel
@using ServiceLayer.SimulationKernel
@using SimulationKernel.Data

<AuthorizeView>
  <Authorized>
    <div class="m-5">
      <div class="col-xl-12">
        <div class="card shadow">
          <div class="card-header">
            <h4>Processings</h4>
          </div>
          <div class="card-body">

            @if (Items == null)
            {
              <p><em>Loading...</em></p>
            }
            else
            {
              <div class="album">
                <div class="container">
                  <div class="row">
                    @foreach (var item in Items)
                    {
                      <SimulationItem Data="@item" JSStore="@_JSStore" />
                    }
                  </div>
                </div>
              </div>
            }

          </div>
        </div>
      </div>


      <div class="col-xl-12  mt-5">
        <div class="card shadow">
          <div class="card-header">
            <div class="btn-toolbar bg-light p-1" role="toolbar" aria-label="Toolbar with button groups">
              <div class="btn-group mr-2" role="group" aria-label="First group">
                <button @onclick="ResetCamera" type="button" class="btn btn-outline-secondary">Reset camera</button>
              </div>
            </div>
          </div>

          <input @oninput="@UpdateFrame"
                 min=0
                 max=@_JSStore.Files.Count
                 disabled="@(!_JSStore.Files.Any())"
                 type="range" class="m-4 form-range" />

          <div @ref=_CanvasHostReference></div>
        </div>
      </div>
    </div>
  </Authorized>

  <NotAuthorized>
    <NotAuthorizedDisplay />
  </NotAuthorized>
</AuthorizeView>

@code {
  private ElementReference _CanvasHostReference;
  private SimulationItem.JSModuleStore _JSStore = default!;
  private IEnumerable<SimulationMetadata>? Items;

  [Inject]
  private IJSRuntime JSRuntime { get; set; } = default!;
  [Inject]
  private ILogger<FetchData> Logger { get; set; } = default!;
  [Inject]
  private ISimulationMetadataService SimulationService { get; set; } = default!;

  [CascadingParameter]
  public Task<AuthenticationState> AuthenticationStateTask { get; set; } = default!;

  protected override void OnInitialized()
  {
    _JSStore = new SimulationItem.JSModuleStore(new List<string>(), () => StateHasChanged());
  }

  protected override async Task OnAfterRenderAsync(bool firstRender)
  {
    if (firstRender)
    {
      var module = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "/js/scene.js");
      if (module != null && _CanvasHostReference.Context != null)
      {
        _JSStore.Module = module;
        await _JSStore.Module.InvokeVoidAsync("renderScene", _CanvasHostReference);
      }
    }
    await base.OnAfterRenderAsync(firstRender);
  }

  protected override async Task OnInitializedAsync()
  {
    await base.OnInitializedAsync();

    var authState = await AuthenticationStateTask;
    var user = authState.User;
    if (user.Identity != null && user.Identity.IsAuthenticated)
    {
      var userName = user.Identity.Name;
      Items = SimulationService.GetUserProcessings(userName, limit: 3);
    }
  }

  private async Task ResetCamera()
  {
    if (_JSStore.Module != null)
    {
      await _JSStore.Module.InvokeVoidAsync("resetCamera");
    }
  }

  private async Task UpdateFrame(ChangeEventArgs e)
  {
    int frame = Convert.ToInt32(e.Value);

    if (_JSStore.Module != null && frame < _JSStore.Files.Count)
    {
      string filePath = _JSStore.Files[frame];
      var content = File.ReadAllBytes(filePath);
      await _JSStore.Module.InvokeVoidAsync("updateSceneFromObject", filePath, content);
    }
  }
}